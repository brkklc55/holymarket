module.exports=[407207,a=>{"use strict";var b=a.i(42657),c=a.i(222541);function d(a){let{key:d="public",name:e="Public Client"}=a;return(0,b.createClient)({...a,key:d,name:e,type:"publicClient"}).extend(c.publicActions)}a.s(["createPublicClient",()=>d])},387871,a=>{"use strict";var b=a.i(429635),c=a.i(327142),d=a.i(986616),e=a.i(463312),f=a.i(850486),g=a.i(336598);async function h(a,h){let{account:i=a.account,chainId:j,nonce:k}=h;if(!i)throw new c.AccountNotFoundError({docsPath:"/docs/eip7702/prepareAuthorization"});let l=(0,b.parseAccount)(i),m=(()=>{if(h.executor)return"self"===h.executor?h.executor:(0,b.parseAccount)(h.executor)})(),n={address:h.contractAddress??h.address,chainId:j,nonce:k};return void 0===n.chainId&&(n.chainId=a.chain?.id??await (0,e.getAction)(a,f.getChainId,"getChainId")({})),void 0===n.nonce&&(n.nonce=await (0,e.getAction)(a,g.getTransactionCount,"getTransactionCount")({address:l.address,blockTag:"pending"}),("self"===m||m?.address&&(0,d.isAddressEqual)(m.address,l.address))&&(n.nonce+=1)),n}a.s(["prepareAuthorization",()=>h])},644051,a=>{"use strict";var b=a.i(671977);class c extends b.BaseError{constructor(a){super(`Call bundle failed with status: ${a.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=a}}a.s(["BundleFailedError",()=>c])},122875,385821,a=>{"use strict";var b=a.i(429635),c=a.i(327142),d=a.i(671977),e=a.i(822261),f=a.i(87933);function g({chain:a,currentChainId:b}){if(!a)throw new f.ChainNotFoundError;if(b!==a.id)throw new f.ChainMismatchError({chain:a,currentChainId:b})}a.s(["assertCurrentChain",()=>g],385821);var h=a.i(754742),i=a.i(443825),j=a.i(344772),k=a.i(463312),l=a.i(924790),m=a.i(311918),n=a.i(850486),o=a.i(803079),p=a.i(260462);let q=new l.LruMap(128);async function r(a,f){let{account:l=a.account,chain:r=a.chain,accessList:s,authorizationList:t,blobs:u,data:v,gas:w,gasPrice:x,maxFeePerBlobGas:y,maxFeePerGas:z,maxPriorityFeePerGas:A,nonce:B,type:C,value:D,...E}=f;if(void 0===l)throw new c.AccountNotFoundError({docsPath:"/docs/actions/wallet/sendTransaction"});let F=l?(0,b.parseAccount)(l):null;try{(0,m.assertRequest)(f);let b=await (async()=>f.to?f.to:null!==f.to&&t&&t.length>0?await (0,e.recoverAuthorizationAddress)({authorization:t[0]}).catch(()=>{throw new d.BaseError("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if(F?.type==="json-rpc"||null===F){let c;null!==r&&(c=await (0,k.getAction)(a,n.getChainId,"getChainId")({}),g({currentChainId:c,chain:r}));let d=a.chain?.formatters?.transactionRequest?.format,e=(d||j.formatTransactionRequest)({...(0,i.extract)(E,{format:d}),accessList:s,account:F,authorizationList:t,blobs:u,chainId:c,data:v,gas:w,gasPrice:x,maxFeePerBlobGas:y,maxFeePerGas:z,maxPriorityFeePerGas:A,nonce:B,to:b,type:C,value:D},"sendTransaction"),f=q.get(a.uid);try{return await a.request({method:f?"wallet_sendTransaction":"eth_sendTransaction",params:[e]},{retryCount:0})}catch(b){if(!1===f)throw b;if("InvalidInputRpcError"===b.name||"InvalidParamsRpcError"===b.name||"MethodNotFoundRpcError"===b.name||"MethodNotSupportedRpcError"===b.name)return await a.request({method:"wallet_sendTransaction",params:[e]},{retryCount:0}).then(b=>(q.set(a.uid,!0),b)).catch(c=>{if("MethodNotFoundRpcError"===c.name||"MethodNotSupportedRpcError"===c.name)throw q.set(a.uid,!1),b;throw c});throw b}}if(F?.type==="local"){let c=await (0,k.getAction)(a,o.prepareTransactionRequest,"prepareTransactionRequest")({account:F,accessList:s,authorizationList:t,blobs:u,chain:r,data:v,gas:w,gasPrice:x,maxFeePerBlobGas:y,maxFeePerGas:z,maxPriorityFeePerGas:A,nonce:B,nonceManager:F.nonceManager,parameters:[...o.defaultParameters,"sidecars"],type:C,value:D,...E,to:b}),d=r?.serializers?.transaction,e=await F.signTransaction(c,{serializer:d});return await (0,k.getAction)(a,p.sendRawTransaction,"sendRawTransaction")({serializedTransaction:e})}if(F?.type==="smart")throw new c.AccountTypeNotSupportedError({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new c.AccountTypeNotSupportedError({docsPath:"/docs/actions/wallet/sendTransaction",type:F?.type})}catch(a){if(a instanceof c.AccountTypeNotSupportedError)throw a;throw(0,h.getTransactionError)(a,{...f,account:F,chain:f.chain||void 0})}}a.s(["sendTransaction",()=>r],122875)},806089,757678,a=>{"use strict";var b=a.i(225677),c=a.i(278072),d=a.i(63363),e=a.i(750140),f=a.i(429635),g=a.i(671977),h=a.i(333102),i=a.i(942587),j=a.i(766096),k=a.i(545913),l=a.i(754742),m=a.i(122875);let n="0x5792579257925792579257925792579257925792579257925792579257925792",o=(0,k.numberToHex)(0,{size:32});async function p(a,b){let{account:c=a.account,capabilities:e,chain:p=a.chain,experimental_fallback:q,experimental_fallbackDelay:r=32,forceAtomic:s=!1,id:t,version:u="2.0.0"}=b,v=c?(0,f.parseAccount)(c):null,w=b.calls.map(a=>{let b=a.abi?(0,i.encodeFunctionData)({abi:a.abi,functionName:a.functionName,args:a.args}):a.data;return{data:a.dataSuffix&&b?(0,j.concat)([b,a.dataSuffix]):b,to:a.to,value:a.value?(0,k.numberToHex)(a.value):void 0}});try{let b=await a.request({method:"wallet_sendCalls",params:[{atomicRequired:s,calls:w,capabilities:e,chainId:(0,k.numberToHex)(p.id),from:v?.address,id:t,version:u}]},{retryCount:0});if("string"==typeof b)return{id:b};return b}catch(c){if(q&&("MethodNotFoundRpcError"===c.name||"MethodNotSupportedRpcError"===c.name||"UnknownRpcError"===c.name||c.details.toLowerCase().includes("does not exist / is not available")||c.details.toLowerCase().includes("missing or invalid. request()")||c.details.toLowerCase().includes("did not match any variant of untagged enum")||c.details.toLowerCase().includes("account upgraded to unsupported contract")||c.details.toLowerCase().includes("eip-7702 not supported")||c.details.toLowerCase().includes("unsupported wc_ method")||c.details.toLowerCase().includes("feature toggled misconfigured")||c.details.toLowerCase().includes("jsonrpcengine: response has no error or result for request"))){if(e&&Object.values(e).some(a=>!a.optional)){let a="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new h.UnsupportedNonOptionalCapabilityError(new g.BaseError(a,{details:a}))}if(s&&w.length>1){let a="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new h.AtomicityNotSupportedError(new g.BaseError(a,{details:a}))}let b=[];for(let c of w){let e=(0,m.sendTransaction)(a,{account:v,chain:p,data:c.data,to:c.to,value:c.value?(0,d.hexToBigInt)(c.value):void 0});b.push(e),r>0&&await new Promise(a=>setTimeout(a,r))}let c=await Promise.allSettled(b);if(c.every(a=>"rejected"===a.status))throw c[0].reason;let f=c.map(a=>"fulfilled"===a.status?a.value:o);return{id:(0,j.concat)([...f,(0,k.numberToHex)(p.id,{size:32}),n])}}throw(0,l.getTransactionError)(c,{...b,account:v,chain:b.chain})}}async function q(a,f){let g;async function h(e){if(e.endsWith(n.slice(2))){let f=(0,c.trim)((0,b.sliceHex)(e,-64,-32)),g=(0,b.sliceHex)(e,0,-64).slice(2).match(/.{1,64}/g),h=await Promise.all(g.map(b=>o.slice(2)!==b?a.request({method:"eth_getTransactionReceipt",params:[`0x${b}`]},{dedupe:!0}):void 0)),i=h.some(a=>null===a)?100:h.every(a=>a?.status==="0x1")?200:h.every(a=>a?.status==="0x0")?500:600;return{atomic:!1,chainId:(0,d.hexToNumber)(f),receipts:h.filter(Boolean),status:i,version:"2.0.0"}}return a.request({method:"wallet_getCallsStatus",params:[e]})}let{atomic:i=!1,chainId:j,receipts:k,version:l="2.0.0",...m}=await h(f.id),[p,q]=(g=m.status)>=100&&g<200?["pending",g]:g>=200&&g<300?["success",g]:g>=300&&g<700?["failure",g]:"CONFIRMED"===g?["success",200]:"PENDING"===g?["pending",100]:[void 0,g];return{...m,atomic:i,chainId:j?(0,d.hexToNumber)(j):void 0,receipts:k?.map(a=>({...a,blockNumber:(0,d.hexToBigInt)(a.blockNumber),gasUsed:(0,d.hexToBigInt)(a.gasUsed),status:e.receiptStatuses[a.status]}))??[],statusCode:q,status:p,version:l}}a.s(["fallbackMagicIdentifier",0,n,"fallbackTransactionErrorMagicIdentifier",0,o,"sendCalls",()=>p],757678),a.s(["getCallsStatus",()=>q],806089)},332340,a=>{"use strict";var b=a.i(671977),c=a.i(644051),d=a.i(463312),e=a.i(18780),f=a.i(16551),g=a.i(481807),h=a.i(953328),i=a.i(213853),j=a.i(806089);async function k(a,b){let k,{id:m,pollingInterval:n=a.pollingInterval,status:o=({statusCode:a})=>200===a||a>=300,retryCount:p=4,retryDelay:q=({count:a})=>200*~~(1<<a),timeout:r=6e4,throwOnFailure:s=!1}=b,t=(0,i.stringify)(["waitForCallsStatus",a.uid,m]),{promise:u,resolve:v,reject:w}=(0,g.withResolvers)(),x=(0,e.observe)(t,{resolve:v,reject:w},b=>{let e=(0,f.poll)(async()=>{let f=a=>{clearTimeout(k),e(),a(),x()};try{let e=await (0,h.withRetry)(async()=>{let b=await (0,d.getAction)(a,j.getCallsStatus,"getCallsStatus")({id:m});if(s&&"failure"===b.status)throw new c.BundleFailedError(b);return b},{retryCount:p,delay:q});if(!o(e))return;f(()=>b.resolve(e))}catch(a){f(()=>b.reject(a))}},{interval:n,emitOnBegin:!0});return e});return k=r?setTimeout(()=>{x(),clearTimeout(k),w(new l({id:m}))},r):void 0,await u}class l extends b.BaseError{constructor({id:a}){super(`Timed out while waiting for call bundle with id "${a}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}a.s(["waitForCallsStatus",()=>k])},684598,a=>{"use strict";var b=a.i(545913);async function c(a,{chain:c}){let{id:d,name:e,nativeCurrency:f,rpcUrls:g,blockExplorers:h}=c;await a.request({method:"wallet_addEthereumChain",params:[{chainId:(0,b.numberToHex)(d),chainName:e,nativeCurrency:f,rpcUrls:g.default.http,blockExplorerUrls:h?Object.values(h).map(({url:a})=>a):void 0}]},{dedupe:!0,retryCount:0})}a.s(["addChain",()=>c])},193077,905508,a=>{"use strict";var b=a.i(901741),c=a.i(122875);function d(a,d){let{abi:e,args:f,bytecode:g,...h}=d,i=(0,b.encodeDeployData)({abi:e,args:f,bytecode:g});return(0,c.sendTransaction)(a,{...h,...h.authorizationList?{to:null}:{},data:i})}a.s(["deployContract",()=>d],193077);var e=a.i(723059);async function f(a){return a.account?.type==="local"?[a.account.address]:(await a.request({method:"eth_accounts"},{dedupe:!0})).map(a=>(0,e.checksumAddress)(a))}a.s(["getAddresses",()=>f],905508)},19525,978892,a=>{"use strict";var b=a.i(429635),c=a.i(545913);async function d(a,e={}){let{account:f=a.account,chainId:g}=e,h=f?(0,b.parseAccount)(f):void 0,i=g?[h?.address,[(0,c.numberToHex)(g)]]:[h?.address],j=await a.request({method:"wallet_getCapabilities",params:i}),k={};for(let[a,b]of Object.entries(j))for(let[c,d]of(k[Number(a)]={},Object.entries(b)))"addSubAccount"===c&&(c="unstable_addSubAccount"),k[Number(a)][c]=d;return"number"==typeof g?k[g]:k}async function e(a){return await a.request({method:"wallet_getPermissions"},{dedupe:!0})}a.s(["getCapabilities",()=>d],19525),a.s(["getPermissions",()=>e],978892)},92001,637667,a=>{"use strict";var b=a.i(723059);async function c(a){return(await a.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(a=>(0,b.getAddress)(a))}async function d(a,b){return a.request({method:"wallet_requestPermissions",params:[b]},{retryCount:0})}a.s(["requestAddresses",()=>c],92001),a.s(["requestPermissions",()=>d],637667)},492985,a=>{"use strict";var b=a.i(42657),c=a.i(176559),d=a.i(850486),e=a.i(684598),f=a.i(193077),g=a.i(905508),h=a.i(806089),i=a.i(19525),j=a.i(978892),k=a.i(387871),l=a.i(803079),m=a.i(92001),n=a.i(637667),o=a.i(757678),p=a.i(332340);async function q(a,b){let{chain:c=a.chain}=b,d=b.timeout??Math.max((c?.blockTime??0)*3,5e3),e=await (0,o.sendCalls)(a,b);return await (0,p.waitForCallsStatus)(a,{...b,id:e.id,timeout:d})}var r=a.i(260462),s=a.i(958170),t=a.i(122875),u=a.i(429635),v=a.i(327142),w=a.i(671977),x=a.i(207389),y=a.i(822261),z=a.i(385821),A=a.i(754742),B=a.i(443825),C=a.i(344772),D=a.i(463312),E=a.i(924790),F=a.i(311918),G=a.i(236313);let H=new E.LruMap(128);async function I(a,b){let{account:c=a.account,chain:e=a.chain,accessList:f,authorizationList:g,blobs:h,data:i,gas:j,gasPrice:k,maxFeePerBlobGas:m,maxFeePerGas:n,maxPriorityFeePerGas:o,nonce:p,pollingInterval:q,throwOnReceiptRevert:r,type:t,value:E,...I}=b,J=b.timeout??Math.max((e?.blockTime??0)*3,5e3);if(void 0===c)throw new v.AccountNotFoundError({docsPath:"/docs/actions/wallet/sendTransactionSync"});let K=c?(0,u.parseAccount)(c):null;try{(0,F.assertRequest)(b);let c=await (async()=>b.to?b.to:null!==b.to&&g&&g.length>0?await (0,y.recoverAuthorizationAddress)({authorization:g[0]}).catch(()=>{throw new w.BaseError("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if(K?.type==="json-rpc"||null===K){let b;null!==e&&(b=await (0,D.getAction)(a,d.getChainId,"getChainId")({}),(0,z.assertCurrentChain)({currentChainId:b,chain:e}));let l=a.chain?.formatters?.transactionRequest?.format,s=(l||C.formatTransactionRequest)({...(0,B.extract)(I,{format:l}),accessList:f,account:K,authorizationList:g,blobs:h,chainId:b,data:i,gas:j,gasPrice:k,maxFeePerBlobGas:m,maxFeePerGas:n,maxPriorityFeePerGas:o,nonce:p,to:c,type:t,value:E},"sendTransaction"),u=H.get(a.uid),v=u?"wallet_sendTransaction":"eth_sendTransaction",w=await (async()=>{try{return await a.request({method:v,params:[s]},{retryCount:0})}catch(b){if(!1===u)throw b;if("InvalidInputRpcError"===b.name||"InvalidParamsRpcError"===b.name||"MethodNotFoundRpcError"===b.name||"MethodNotSupportedRpcError"===b.name)return await a.request({method:"wallet_sendTransaction",params:[s]},{retryCount:0}).then(b=>(H.set(a.uid,!0),b)).catch(c=>{if("MethodNotFoundRpcError"===c.name||"MethodNotSupportedRpcError"===c.name)throw H.set(a.uid,!1),b;throw c});throw b}})(),y=await (0,D.getAction)(a,G.waitForTransactionReceipt,"waitForTransactionReceipt")({checkReplacement:!1,hash:w,pollingInterval:q,timeout:J});if(r&&"reverted"===y.status)throw new x.TransactionReceiptRevertedError({receipt:y});return y}if(K?.type==="local"){let b=await (0,D.getAction)(a,l.prepareTransactionRequest,"prepareTransactionRequest")({account:K,accessList:f,authorizationList:g,blobs:h,chain:e,data:i,gas:j,gasPrice:k,maxFeePerBlobGas:m,maxFeePerGas:n,maxPriorityFeePerGas:o,nonce:p,nonceManager:K.nonceManager,parameters:[...l.defaultParameters,"sidecars"],type:t,value:E,...I,to:c}),d=e?.serializers?.transaction,q=await K.signTransaction(b,{serializer:d});return await (0,D.getAction)(a,s.sendRawTransactionSync,"sendRawTransactionSync")({serializedTransaction:q,throwOnReceiptRevert:r})}if(K?.type==="smart")throw new v.AccountTypeNotSupportedError({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new v.AccountTypeNotSupportedError({docsPath:"/docs/actions/wallet/sendTransactionSync",type:K?.type})}catch(a){if(a instanceof v.AccountTypeNotSupportedError)throw a;throw(0,A.getTransactionError)(a,{...b,account:K,chain:b.chain||void 0})}}async function J(a,b){let{id:c}=b;await a.request({method:"wallet_showCallsStatus",params:[c]})}async function K(a,b){let{account:c=a.account}=b;if(!c)throw new v.AccountNotFoundError({docsPath:"/docs/eip7702/signAuthorization"});let d=(0,u.parseAccount)(c);if(!d.signAuthorization)throw new v.AccountTypeNotSupportedError({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:d.type});let e=await (0,k.prepareAuthorization)(a,b);return d.signAuthorization(e)}var L=a.i(477067),M=a.i(545913);async function N(a,b){let{account:c=a.account,chain:e=a.chain,...f}=b;if(!c)throw new v.AccountNotFoundError({docsPath:"/docs/actions/wallet/signTransaction"});let g=(0,u.parseAccount)(c);(0,F.assertRequest)({account:g,...b});let h=await (0,D.getAction)(a,d.getChainId,"getChainId")({});null!==e&&(0,z.assertCurrentChain)({currentChainId:h,chain:e});let i=e?.formatters||a.chain?.formatters,j=i?.transactionRequest?.format||C.formatTransactionRequest;return g.signTransaction?g.signTransaction({...f,chainId:h},{serializer:a.chain?.serializers?.transaction}):await a.request({method:"eth_signTransaction",params:[{...j({...f,account:g},"signTransaction"),chainId:(0,M.numberToHex)(h),from:g.address}]},{retryCount:0})}var O=a.i(544240);async function P(a,b){let{account:c=a.account,domain:d,message:e,primaryType:f}=b;if(!c)throw new v.AccountNotFoundError({docsPath:"/docs/actions/wallet/signTypedData"});let g=(0,u.parseAccount)(c),h={EIP712Domain:(0,O.getTypesForEIP712Domain)({domain:d}),...b.types};if((0,O.validateTypedData)({domain:d,message:e,primaryType:f,types:h}),g.signTypedData)return g.signTypedData({domain:d,message:e,primaryType:f,types:h});let i=(0,O.serializeTypedData)({domain:d,message:e,primaryType:f,types:h});return a.request({method:"eth_signTypedData_v4",params:[g.address,i]},{retryCount:0})}async function Q(a,{id:b}){await a.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,M.numberToHex)(b)}]},{retryCount:0})}async function R(a,b){return await a.request({method:"wallet_watchAsset",params:b},{retryCount:0})}var S=a.i(942587),T=a.i(530048);async function U(a,b){return U.internal(a,t.sendTransaction,"sendTransaction",b)}async function V(a,b){return U.internal(a,I,"sendTransactionSync",b)}function W(a){return{addChain:b=>(0,e.addChain)(a,b),deployContract:b=>(0,f.deployContract)(a,b),fillTransaction:b=>(0,c.fillTransaction)(a,b),getAddresses:()=>(0,g.getAddresses)(a),getCallsStatus:b=>(0,h.getCallsStatus)(a,b),getCapabilities:b=>(0,i.getCapabilities)(a,b),getChainId:()=>(0,d.getChainId)(a),getPermissions:()=>(0,j.getPermissions)(a),prepareAuthorization:b=>(0,k.prepareAuthorization)(a,b),prepareTransactionRequest:b=>(0,l.prepareTransactionRequest)(a,b),requestAddresses:()=>(0,m.requestAddresses)(a),requestPermissions:b=>(0,n.requestPermissions)(a,b),sendCalls:b=>(0,o.sendCalls)(a,b),sendCallsSync:b=>q(a,b),sendRawTransaction:b=>(0,r.sendRawTransaction)(a,b),sendRawTransactionSync:b=>(0,s.sendRawTransactionSync)(a,b),sendTransaction:b=>(0,t.sendTransaction)(a,b),sendTransactionSync:b=>I(a,b),showCallsStatus:b=>J(a,b),signAuthorization:b=>K(a,b),signMessage:b=>(0,L.signMessage)(a,b),signTransaction:b=>N(a,b),signTypedData:b=>P(a,b),switchChain:b=>Q(a,b),waitForCallsStatus:b=>(0,p.waitForCallsStatus)(a,b),watchAsset:b=>R(a,b),writeContract:b=>U(a,b),writeContractSync:b=>V(a,b)}}function X(a){let{key:c="wallet",name:d="Wallet Client",transport:e}=a;return(0,b.createClient)({...a,key:c,name:d,transport:e,type:"walletClient"}).extend(W)}(U||(U={})).internal=async function(a,b,c,d){let{abi:e,account:f=a.account,address:g,args:h,dataSuffix:i,functionName:j,...k}=d;if(void 0===f)throw new v.AccountNotFoundError({docsPath:"/docs/contract/writeContract"});let l=f?(0,u.parseAccount)(f):null,m=(0,S.encodeFunctionData)({abi:e,args:h,functionName:j});try{return await (0,D.getAction)(a,b,c)({data:`${m}${i?i.replace("0x",""):""}`,to:g,account:l,...k})}catch(a){throw(0,T.getContractError)(a,{abi:e,address:g,args:h,docsPath:"/docs/contract/writeContract",functionName:j,sender:l?.address})}},a.s(["createWalletClient",()=>X],492985)},462645,a=>{"use strict";var b=a.i(671977);class c extends b.BaseError{constructor({value:a}){super(`Number \`${a}\` is not a valid decimal number.`,{name:"InvalidDecimalNumberError"})}}function d(a,b){if(!/^(-?)([0-9]*)\.?([0-9]*)$/.test(a))throw new c({value:a});let[d,e="0"]=a.split("."),f=d.startsWith("-");if(f&&(d=d.slice(1)),e=e.replace(/(0+)$/,""),0===b)1===Math.round(Number(`.${e}`))&&(d=`${BigInt(d)+1n}`),e="";else if(e.length>b){let[a,c,f]=[e.slice(0,b-1),e.slice(b-1,b),e.slice(b)],g=Math.round(Number(`${c}.${f}`));(e=g>9?`${BigInt(a)+BigInt(1)}0`.padStart(a.length+1,"0"):`${a}${g}`).length>b&&(e=e.slice(1),d=`${BigInt(d)+1n}`),e=e.slice(0,b)}else e=e.padEnd(b,"0");return BigInt(`${f?"-":""}${d}${e}`)}a.s(["parseUnits",()=>d],462645)}];

//# sourceMappingURL=28ea8_viem__esm_e8e4e800._.js.map