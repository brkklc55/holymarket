{"version":3,"sources":["../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/data/concat.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/abi/formatAbiItem.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/data/isHex.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/data/size.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/version.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/base.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/abi.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/address.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/encoding.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/lru.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/data.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/data/pad.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/data/trim.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/encoding/toBytes.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/hash/keccak256.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/encoding/toHex.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/encoding/fromHex.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/address/getAddress.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/address/isAddress.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/data/slice.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/regex.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/abi/encodeAbiParameters.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/hash/normalizeSignature.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/hash/hashSignature.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/hash/toSignatureHash.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/hash/toSignature.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/abitype/src/human-readable/formatAbiItem.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/hash/toFunctionSelector.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/hash/toEventSelector.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/abi/getAbiItem.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/abi/encodeFunctionData.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/abi/prepareEncodeFunctionData.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/constants/unit.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/formatters/formatter.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/cursor.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/cursor.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/transaction.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/unit/formatUnits.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/unit/formatEther.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/utils/unit/formatGwei.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/constants/number.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/chain.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/viem/errors/node.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<value extends Hex | ByteArray> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<value extends Hex | ByteArray>(\n  values: readonly value[],\n): ConcatReturnType<value> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<value>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<value>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsHexErrorType = ErrorType\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean | undefined } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\n\nexport type SizeErrorType = IsHexErrorType | ErrorType\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","export const version = '2.43.2'\n","import { version } from './version.js'\n\ntype ErrorConfig = {\n  getDocsUrl?: ((args: BaseErrorParameters) => string | undefined) | undefined\n  version?: string | undefined\n}\n\nlet errorConfig: ErrorConfig = {\n  getDocsUrl: ({\n    docsBaseUrl,\n    docsPath = '',\n    docsSlug,\n  }: BaseErrorParameters) =>\n    docsPath\n      ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${\n          docsSlug ? `#${docsSlug}` : ''\n        }`\n      : undefined,\n  version: `viem@${version}`,\n}\n\nexport function setErrorConfig(config: ErrorConfig) {\n  errorConfig = config\n}\n\ntype BaseErrorParameters = {\n  cause?: BaseError | Error | undefined\n  details?: string | undefined\n  docsBaseUrl?: string | undefined\n  docsPath?: string | undefined\n  docsSlug?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n  version: string\n\n  override name = 'BaseError'\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details = (() => {\n      if (args.cause instanceof BaseError) return args.cause.details\n      if (args.cause?.message) return args.cause.message\n      return args.details!\n    })()\n    const docsPath = (() => {\n      if (args.cause instanceof BaseError)\n        return args.cause.docsPath || args.docsPath\n      return args.docsPath\n    })()\n    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath })\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsUrl ? [`Docs: ${docsUrl}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),\n    ].join('\\n')\n\n    super(message, args.cause ? { cause: args.cause } : undefined)\n\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.name = args.name ?? this.name\n    this.shortMessage = shortMessage\n    this.version = version\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (\n    err &&\n    typeof err === 'object' &&\n    'cause' in err &&\n    err.cause !== undefined\n  )\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n      name: 'InvalidAddressError',\n    })\n  }\n}\n","import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {\n  name: 'IntegerOutOfRangeError'\n}\nexport class IntegerOutOfRangeError extends BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n      { name: 'IntegerOutOfRangeError' },\n    )\n  }\n}\n\nexport type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {\n  name: 'InvalidBytesBooleanError'\n}\nexport class InvalidBytesBooleanError extends BaseError {\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n      {\n        name: 'InvalidBytesBooleanError',\n      },\n    )\n  }\n}\n\nexport type InvalidHexBooleanErrorType = InvalidHexBooleanError & {\n  name: 'InvalidHexBooleanError'\n}\nexport class InvalidHexBooleanError extends BaseError {\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n      { name: 'InvalidHexBooleanError' },\n    )\n  }\n}\n\nexport type InvalidHexValueErrorType = InvalidHexValueError & {\n  name: 'InvalidHexValueError'\n}\nexport class InvalidHexValueError extends BaseError {\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n      { name: 'InvalidHexValueError' },\n    )\n  }\n}\n\nexport type SizeOverflowErrorType = SizeOverflowError & {\n  name: 'SizeOverflowError'\n}\nexport class SizeOverflowError extends BaseError {\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n      { name: 'SizeOverflowError' },\n    )\n  }\n}\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n      { name: 'SliceOffsetOutOfBoundsError' },\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n      { name: 'SizeExceedsPaddingSizeError' },\n    )\n  }\n}\n\nexport type InvalidBytesLengthErrorType = InvalidBytesLengthError & {\n  name: 'InvalidBytesLengthError'\n}\nexport class InvalidBytesLengthError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,\n      { name: 'InvalidBytesLengthError' },\n    )\n  }\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype TrimOptions = {\n  dir?: 'left' | 'right' | undefined\n}\nexport type TrimReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type TrimErrorType = ErrorType\n\nexport function trim<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir = 'left' }: TrimOptions = {},\n): TrimReturnType<value> {\n  let data: any =\n    typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (typeof hexOrBytes === 'string') {\n    if (data.length === 1 && dir === 'right') data = `${data}0`\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<value>\n  }\n  return data as TrimReturnType<value>\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | to\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromHexReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'bigint'\n    ? bigint\n    : to extends 'number'\n      ? number\n      : to extends 'bytes'\n        ? ByteArray\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<to>): FromHexReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<to>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<to>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<to>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<to>\n  return hexToBytes(hex, opts) as FromHexReturnType<to>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n  const cacheKey = `${address}.${strict}`\n\n  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(cacheKey, result)\n  return result\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type {\n  AbiParameter,\n  AbiParameterKind,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params, AbiParameterKind, true>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize, 10))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize, 10),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport type { AbiFunctionNotFoundErrorType } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport type { ToFunctionSelectorErrorType } from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport type { FormatAbiItemErrorType } from './formatAbiItem.js'\nimport type { GetAbiItemErrorType } from './getAbiItem.js'\nimport { prepareEncodeFunctionData } from './prepareEncodeFunctionData.js'\n\nexport type EncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | Hex\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<\n    readonly [] extends allArgs\n      ? { args?: allArgs | undefined }\n      : { args: allArgs }\n  > &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionDataReturnType = Hex\n\nexport type EncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | EncodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function encodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionDataParameters<abi, functionName>,\n): EncodeFunctionDataReturnType {\n  const { args } = parameters as EncodeFunctionDataParameters\n\n  const { abi, functionName } = (() => {\n    if (\n      parameters.abi.length === 1 &&\n      parameters.functionName?.startsWith('0x')\n    )\n      return parameters as { abi: Abi; functionName: Hex }\n    return prepareEncodeFunctionData(parameters)\n  })()\n\n  const abiItem = abi[0]\n  const signature = functionName\n\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, args ?? [])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n","import type {\n  Abi,\n  AbiStateMutability,\n  ExtractAbiFunction,\n  ExtractAbiFunctions,\n} from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport type { ConcatHexErrorType } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionData'\n\nexport type PrepareEncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<{ args?: allArgs | undefined }> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type PrepareEncodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n> = {\n  abi: abi extends Abi\n    ? functionName extends ContractFunctionName<abi>\n      ? [ExtractAbiFunction<abi, functionName>]\n      : abi\n    : Abi\n  functionName: Hex\n}\n\nexport type PrepareEncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function prepareEncodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: PrepareEncodeFunctionDataParameters<abi, functionName>,\n): PrepareEncodeFunctionDataReturnType<abi, functionName> {\n  const { abi, args, functionName } =\n    parameters as PrepareEncodeFunctionDataParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  return {\n    abi: [abiItem],\n    functionName: toFunctionSelector(formatAbiItem(abiItem)),\n  } as unknown as PrepareEncodeFunctionDataReturnType<abi, functionName>\n}\n","export const etherUnits = {\n  gwei: 9,\n  wei: 18,\n}\nexport const gweiUnits = {\n  ether: -9,\n  wei: 9,\n}\nexport const weiUnits = {\n  ether: -18,\n  gwei: -9,\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Prettify } from '../../types/utils.js'\n\nexport type DefineFormatterErrorType = ErrorType\n\nexport function defineFormatter<type extends string, parameters, returnType>(\n  type: type,\n  format: (args: parameters, action?: string | undefined) => returnType,\n) {\n  return <\n    parametersOverride,\n    returnTypeOverride,\n    exclude extends (keyof parameters | keyof parametersOverride)[] = [],\n  >({\n    exclude,\n    format: overrides,\n  }: {\n    exclude?: exclude | undefined\n    format: (\n      args: parametersOverride,\n      action?: string | undefined,\n    ) => returnTypeOverride\n  }) => {\n    return {\n      exclude,\n      format: (args: parametersOverride, action?: string | undefined) => {\n        const formatted = format(args as any, action)\n        if (exclude) {\n          for (const key of exclude) {\n            delete (formatted as any)[key]\n          }\n        }\n        return {\n          ...formatted,\n          ...overrides(args, action),\n        } as Prettify<returnTypeOverride> & {\n          [_key in exclude[number]]: never\n        }\n      },\n      type,\n    }\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type NegativeOffsetErrorType = NegativeOffsetError & {\n  name: 'NegativeOffsetError'\n}\nexport class NegativeOffsetError extends BaseError {\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`, {\n      name: 'NegativeOffsetError',\n    })\n  }\n}\n\nexport type PositionOutOfBoundsErrorType = PositionOutOfBoundsError & {\n  name: 'PositionOutOfBoundsError'\n}\nexport class PositionOutOfBoundsError extends BaseError {\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n      { name: 'PositionOutOfBoundsError' },\n    )\n  }\n}\n\nexport type RecursiveReadLimitExceededErrorType =\n  RecursiveReadLimitExceededError & {\n    name: 'RecursiveReadLimitExceededError'\n  }\nexport class RecursiveReadLimitExceededError extends BaseError {\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n      { name: 'RecursiveReadLimitExceededError' },\n    )\n  }\n}\n","import {\n  NegativeOffsetError,\n  type NegativeOffsetErrorType,\n  PositionOutOfBoundsError,\n  type PositionOutOfBoundsErrorType,\n  RecursiveReadLimitExceededError,\n  type RecursiveReadLimitExceededErrorType,\n} from '../errors/cursor.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ByteArray } from '../types/misc.js'\n\nexport type Cursor = {\n  bytes: ByteArray\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): ByteArray[number]\n  inspectBytes(length: number, position?: number): ByteArray\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: ByteArray[number]): void\n  pushBytes(bytes: ByteArray): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): ByteArray[number]\n  readBytes(length: number, size?: number): ByteArray\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\ntype CursorErrorType =\n  | CursorAssertPositionErrorType\n  | CursorDecrementPositionErrorType\n  | CursorIncrementPositionErrorType\n  | ErrorType\n\ntype CursorAssertPositionErrorType = PositionOutOfBoundsErrorType | ErrorType\n\ntype CursorDecrementPositionErrorType = NegativeOffsetErrorType | ErrorType\n\ntype CursorIncrementPositionErrorType = NegativeOffsetErrorType | ErrorType\n\ntype StaticCursorErrorType =\n  | NegativeOffsetErrorType\n  | RecursiveReadLimitExceededErrorType\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: ByteArray[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: ByteArray) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\ntype CursorConfig = { recursiveReadLimit?: number | undefined }\n\nexport type CreateCursorErrorType =\n  | CursorErrorType\n  | StaticCursorErrorType\n  | ErrorType\n\nexport function createCursor(\n  bytes: ByteArray,\n  { recursiveReadLimit = 8_192 }: CursorConfig = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer ?? bytes,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n","import type { Account } from '../accounts/types.js'\nimport type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'\nimport type { BlockTag } from '../types/block.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hash, Hex } from '../types/misc.js'\nimport type {\n  TransactionReceipt,\n  TransactionType,\n} from '../types/transaction.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport type FeeConflictErrorType = FeeConflictError & {\n  name: 'FeeConflictError'\n}\nexport class FeeConflictError extends BaseError {\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n      { name: 'FeeConflictError' },\n    )\n  }\n}\n\nexport type InvalidLegacyVErrorType = InvalidLegacyVError & {\n  name: 'InvalidLegacyVError'\n}\nexport class InvalidLegacyVError extends BaseError {\n  constructor({ v }: { v: bigint }) {\n    super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`, {\n      name: 'InvalidLegacyVError',\n    })\n  }\n}\n\nexport type InvalidSerializableTransactionErrorType =\n  InvalidSerializableTransactionError & {\n    name: 'InvalidSerializableTransactionError'\n  }\nexport class InvalidSerializableTransactionError extends BaseError {\n  constructor({ transaction }: { transaction: Record<string, unknown> }) {\n    super('Cannot infer a transaction type from provided transaction.', {\n      metaMessages: [\n        'Provided Transaction:',\n        '{',\n        prettyPrint(transaction),\n        '}',\n        '',\n        'To infer the type, either provide:',\n        '- a `type` to the Transaction, or',\n        '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n        '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',\n        '- an EIP-7702 Transaction with `authorizationList`, or',\n        '- a Legacy Transaction with `gasPrice`',\n      ],\n      name: 'InvalidSerializableTransactionError',\n    })\n  }\n}\n\nexport type InvalidSerializedTransactionTypeErrorType =\n  InvalidSerializedTransactionTypeError & {\n    name: 'InvalidSerializedTransactionTypeError'\n  }\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n  serializedType: Hex\n\n  constructor({ serializedType }: { serializedType: Hex }) {\n    super(`Serialized transaction type \"${serializedType}\" is invalid.`, {\n      name: 'InvalidSerializedTransactionType',\n    })\n\n    this.serializedType = serializedType\n  }\n}\n\nexport type InvalidSerializedTransactionErrorType =\n  InvalidSerializedTransactionError & {\n    name: 'InvalidSerializedTransactionError'\n  }\nexport class InvalidSerializedTransactionError extends BaseError {\n  serializedTransaction: Hex\n  type: TransactionType\n\n  constructor({\n    attributes,\n    serializedTransaction,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serializedTransaction: Hex\n    type: TransactionType\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serializedTransaction}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n      name: 'InvalidSerializedTransactionError',\n    })\n\n    this.serializedTransaction = serializedTransaction\n    this.type = type\n  }\n}\n\nexport type InvalidStorageKeySizeErrorType = InvalidStorageKeySizeError & {\n  name: 'InvalidStorageKeySizeError'\n}\nexport class InvalidStorageKeySizeError extends BaseError {\n  constructor({ storageKey }: { storageKey: Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor(\n        (storageKey.length - 2) / 2,\n      )} bytes.`,\n      { name: 'InvalidStorageKeySizeError' },\n    )\n  }\n}\n\nexport type TransactionExecutionErrorType = TransactionExecutionError & {\n  name: 'TransactionExecutionError'\n}\nexport class TransactionExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {\n      account: Account | null\n      chain?: Chain | undefined\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'TransactionExecutionError',\n    })\n    this.cause = cause\n  }\n}\n\nexport type TransactionNotFoundErrorType = TransactionNotFoundError & {\n  name: 'TransactionNotFoundError'\n}\nexport class TransactionNotFoundError extends BaseError {\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash | undefined\n    blockNumber?: bigint | undefined\n    blockTag?: BlockTag | undefined\n    hash?: Hash | undefined\n    index?: number | undefined\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`, {\n      name: 'TransactionNotFoundError',\n    })\n  }\n}\n\nexport type TransactionReceiptNotFoundErrorType =\n  TransactionReceiptNotFoundError & {\n    name: 'TransactionReceiptNotFoundError'\n  }\nexport class TransactionReceiptNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n      {\n        name: 'TransactionReceiptNotFoundError',\n      },\n    )\n  }\n}\n\nexport type TransactionReceiptRevertedErrorType =\n  TransactionReceiptRevertedError & {\n    name: 'TransactionReceiptRevertedError'\n  }\nexport class TransactionReceiptRevertedError extends BaseError {\n  receipt: TransactionReceipt\n\n  constructor({ receipt }: { receipt: TransactionReceipt }) {\n    super(`Transaction with hash \"${receipt.transactionHash}\" reverted.`, {\n      metaMessages: [\n        'The receipt marked the transaction as \"reverted\". This could mean that the function on the contract you are trying to call threw an error.',\n        ' ',\n        'You can attempt to extract the revert reason by:',\n        '- calling the `simulateContract` or `simulateCalls` Action with the `abi` and `functionName` of the contract',\n        '- using the `call` Action with raw `data`',\n      ],\n      name: 'TransactionReceiptRevertedError',\n    })\n\n    this.receipt = receipt\n  }\n}\n\nexport type WaitForTransactionReceiptTimeoutErrorType =\n  WaitForTransactionReceiptTimeoutError & {\n    name: 'WaitForTransactionReceiptTimeoutError'\n  }\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n      { name: 'WaitForTransactionReceiptTimeoutError' },\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\n\nexport type FormatUnitsErrorType = ErrorType\n\n/**\n *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..\n *\n * - Docs: https://viem.sh/docs/utilities/formatUnits\n *\n * @example\n * import { formatUnits } from 'viem'\n *\n * formatUnits(420000000000n, 9)\n * // '420'\n */\nexport function formatUnits(value: bigint, decimals: number) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n","import { etherUnits } from '../../constants/unit.js'\n\nimport { type FormatUnitsErrorType, formatUnits } from './formatUnits.js'\n\nexport type FormatEtherErrorType = FormatUnitsErrorType\n\n/**\n * Converts numerical wei to a string representation of ether.\n *\n * - Docs: https://viem.sh/docs/utilities/formatEther\n *\n * @example\n * import { formatEther } from 'viem'\n *\n * formatEther(1000000000000000000n)\n * // '1'\n */\nexport function formatEther(wei: bigint, unit: 'wei' | 'gwei' = 'wei') {\n  return formatUnits(wei, etherUnits[unit])\n}\n","import { gweiUnits } from '../../constants/unit.js'\n\nimport { type FormatUnitsErrorType, formatUnits } from './formatUnits.js'\n\nexport type FormatGweiErrorType = FormatUnitsErrorType\n\n/**\n * Converts numerical wei to a string representation of gwei.\n *\n * - Docs: https://viem.sh/docs/utilities/formatGwei\n *\n * @example\n * import { formatGwei } from 'viem'\n *\n * formatGwei(1000000000n)\n * // '1'\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n","export const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import type { Chain } from '../types/chain.js'\n\nimport { BaseError } from './base.js'\n\nexport type ChainDoesNotSupportContractErrorType =\n  ChainDoesNotSupportContract & {\n    name: 'ChainDoesNotSupportContract'\n  }\nexport class ChainDoesNotSupportContract extends BaseError {\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint | undefined\n    chain: Chain\n    contract: { name: string; blockCreated?: number | undefined }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n        name: 'ChainDoesNotSupportContract',\n      },\n    )\n  }\n}\n\nexport type ChainMismatchErrorType = ChainMismatchError & {\n  name: 'ChainMismatchError'\n}\nexport class ChainMismatchError extends BaseError {\n  constructor({\n    chain,\n    currentChainId,\n  }: {\n    chain: Chain\n    currentChainId: number\n  }) {\n    super(\n      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id}  ${chain.name}`,\n        ],\n        name: 'ChainMismatchError',\n      },\n    )\n  }\n}\n\nexport type ChainNotFoundErrorType = ChainNotFoundError & {\n  name: 'ChainNotFoundError'\n}\nexport class ChainNotFoundError extends BaseError {\n  constructor() {\n    super(\n      [\n        'No chain was provided to the request.',\n        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n      ].join('\\n'),\n      {\n        name: 'ChainNotFoundError',\n      },\n    )\n  }\n}\n\nexport type ClientChainNotConfiguredErrorType =\n  ClientChainNotConfiguredError & {\n    name: 'ClientChainNotConfiguredError'\n  }\nexport class ClientChainNotConfiguredError extends BaseError {\n  constructor() {\n    super('No chain was provided to the Client.', {\n      name: 'ClientChainNotConfiguredError',\n    })\n  }\n}\n\nexport type InvalidChainIdErrorType = InvalidChainIdError & {\n  name: 'InvalidChainIdError'\n}\nexport class InvalidChainIdError extends BaseError {\n  constructor({ chainId }: { chainId?: number | undefined }) {\n    super(\n      typeof chainId === 'number'\n        ? `Chain ID \"${chainId}\" is invalid.`\n        : 'Chain ID is invalid.',\n      { name: 'InvalidChainIdError' },\n    )\n  }\n}\n","import { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: 3\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted|gas required exceeds allowance/\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError | undefined; message?: string | undefined } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n        name: 'ExecutionRevertedError',\n      },\n    )\n  }\n}\n\nexport type FeeCapTooHighErrorType = FeeCapTooHighError & {\n  name: 'FeeCapTooHighError'\n}\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n        name: 'FeeCapTooHighError',\n      },\n    )\n  }\n}\n\nexport type FeeCapTooLowErrorType = FeeCapTooLowError & {\n  name: 'FeeCapTooLowError'\n}\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n        name: 'FeeCapTooLowError',\n      },\n    )\n  }\n}\n\nexport type NonceTooHighErrorType = NonceTooHighError & {\n  name: 'NonceTooHighError'\n}\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause, name: 'NonceTooHighError' },\n    )\n  }\n}\n\nexport type NonceTooLowErrorType = NonceTooLowError & {\n  name: 'NonceTooLowError'\n}\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage =\n    /nonce too low|transaction already imported|already known/\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause, name: 'NonceTooLowError' },\n    )\n  }\n}\n\nexport type NonceMaxValueErrorType = NonceMaxValueError & {\n  name: 'NonceMaxValueError'\n}\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause, name: 'NonceMaxValueError' },\n    )\n  }\n}\n\nexport type InsufficientFundsErrorType = InsufficientFundsError & {\n  name: 'InsufficientFundsError'\n}\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage =\n    /insufficient funds|exceeds transaction sender account balance/\n  constructor({ cause }: { cause?: BaseError | undefined } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n        name: 'InsufficientFundsError',\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooHighErrorType = IntrinsicGasTooHighError & {\n  name: 'IntrinsicGasTooHighError'\n}\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n        name: 'IntrinsicGasTooHighError',\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooLowErrorType = IntrinsicGasTooLowError & {\n  name: 'IntrinsicGasTooLowError'\n}\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n        name: 'IntrinsicGasTooLowError',\n      },\n    )\n  }\n}\n\nexport type TransactionTypeNotSupportedErrorType =\n  TransactionTypeNotSupportedError & {\n    name: 'TransactionTypeNotSupportedError'\n  }\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n      name: 'TransactionTypeNotSupportedError',\n    })\n  }\n}\n\nexport type TipAboveFeeCapErrorType = TipAboveFeeCapError & {\n  name: 'TipAboveFeeCapError'\n}\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxPriorityFeePerGas?: bigint | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n        name: 'TipAboveFeeCapError',\n      },\n    )\n  }\n}\n\nexport type UnknownNodeErrorType = UnknownNodeError & {\n  name: 'UnknownNodeError'\n}\nexport class UnknownNodeError extends BaseError {\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(`An error occurred while executing: ${cause?.shortMessage}`, {\n      cause,\n      name: 'UnknownNodeError',\n    })\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5,12,13,14,15,16,20,21,22,23,24,25,26,30,31,34,35,36,37,38,39]}