{"version":3,"sources":["../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/%40noble/hashes/src/hmac.ts","../../../../../../../.gemini/antigravity/scratch/folymarket/node_modules/abitype/src/human-readable/parseAbiParameters.ts"],"sourcesContent":["/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n","import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n> =\n  | (params extends string\n      ? params extends ''\n        ? never\n        : string extends params\n          ? readonly AbiParameter[]\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\n      : never)\n  | (params extends readonly string[]\n      ? string[] extends params\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<params> extends infer structs\n          ? {\n              [key in keyof params]: params[key] extends string\n                ? IsStructSignature<params[key]> extends true\n                  ? never\n                  : ParseAbiParameters_<\n                      SplitParameters<params[key]>,\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends readonly [...infer content]\n              ? content['length'] extends 0\n                ? never\n                : DeepFlatten<content>\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Flatten all members of {@link T}\n *\n * @param T - List of items to flatten\n * @param Acc - The accumulator used while recursing\n * @returns The flattened array\n *\n * @example\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\n * //   ^? type Result = ['a', 'b', 'c']\n */\ntype DeepFlatten<\n  T extends readonly unknown[],\n  Acc extends readonly unknown[] = readonly [],\n> = T extends readonly [infer head, ...infer tail]\n  ? tail extends undefined\n    ? never\n    : head extends readonly unknown[]\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\n      : DeepFlatten<tail, readonly [...Acc, head]>\n  : Acc\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<params> &\n    (\n      | (params extends string\n          ? params extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (params extends readonly string[]\n          ? params extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends params\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<params> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<params>\n}\n"],"names":[],"mappings":"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"}