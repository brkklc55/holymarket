(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,577890,e=>{"use strict";var t=e.i(464265),r=e.i(624323);function a(e){let{key:a="public",name:i="Public Client"}=e;return(0,t.createClient)({...e,key:a,name:i,type:"publicClient"}).extend(r.publicActions)}e.s(["createPublicClient",()=>a])},364775,e=>{"use strict";var t=e.i(45710);class r extends t.BaseError{constructor({value:e}){super(`Number \`${e}\` is not a valid decimal number.`,{name:"InvalidDecimalNumberError"})}}function a(e,t){if(!/^(-?)([0-9]*)\.?([0-9]*)$/.test(e))throw new r({value:e});let[a,i="0"]=e.split("."),n=a.startsWith("-");if(n&&(a=a.slice(1)),i=i.replace(/(0+)$/,""),0===t)1===Math.round(Number(`.${i}`))&&(a=`${BigInt(a)+1n}`),i="";else if(i.length>t){let[e,r,n]=[i.slice(0,t-1),i.slice(t-1,t),i.slice(t)],o=Math.round(Number(`${r}.${n}`));(i=o>9?`${BigInt(e)+BigInt(1)}0`.padStart(e.length+1,"0"):`${e}${o}`).length>t&&(i=i.slice(1),a=`${BigInt(a)+1n}`),i=i.slice(0,t)}else i=i.padEnd(t,"0");return BigInt(`${n?"-":""}${a}${i}`)}e.s(["parseUnits",()=>a],364775)},541370,627956,503501,427015,e=>{"use strict";var t=e.i(241806),r=e.i(49570),a=e.i(509778),i=e.i(943446),n=e.i(534516),o=e.i(45710),s=e.i(478260),c=e.i(967868),l=e.i(425218),u=e.i(656460),d=e.i(936179),p=e.i(12933),h=e.i(229921),m=e.i(204534);function w({chain:e,currentChainId:t}){if(!e)throw new m.ChainNotFoundError;if(t!==e.id)throw new m.ChainMismatchError({chain:e,currentChainId:t})}e.s(["assertCurrentChain",()=>w],627956);var f=e.i(862440),g=e.i(526766),v=e.i(914862),b=e.i(866010),T=e.i(967944),C=e.i(828848),y=e.i(465321),E=e.i(206807);let x=new b.LruMap(128);async function A(e,t){let{account:r=e.account,chain:a=e.chain,accessList:i,authorizationList:s,blobs:c,data:l,gas:u,gasPrice:m,maxFeePerBlobGas:b,maxFeePerGas:A,maxPriorityFeePerGas:I,nonce:N,type:R,value:B,...S}=t;if(void 0===r)throw new p.AccountNotFoundError({docsPath:"/docs/actions/wallet/sendTransaction"});let $=r?(0,n.parseAccount)(r):null;try{(0,T.assertRequest)(t);let r=await (async()=>t.to?t.to:null!==t.to&&s&&s.length>0?await (0,h.recoverAuthorizationAddress)({authorization:s[0]}).catch(()=>{throw new o.BaseError("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if($?.type==="json-rpc"||null===$){let t;null!==a&&(t=await (0,v.getAction)(e,C.getChainId,"getChainId")({}),w({currentChainId:t,chain:a}));let n=e.chain?.formatters?.transactionRequest?.format,o=(n||g.formatTransactionRequest)({...(0,f.extract)(S,{format:n}),accessList:i,account:$,authorizationList:s,blobs:c,chainId:t,data:l,gas:u,gasPrice:m,maxFeePerBlobGas:b,maxFeePerGas:A,maxPriorityFeePerGas:I,nonce:N,to:r,type:R,value:B},"sendTransaction"),d=x.get(e.uid);try{return await e.request({method:d?"wallet_sendTransaction":"eth_sendTransaction",params:[o]},{retryCount:0})}catch(t){if(!1===d)throw t;if("InvalidInputRpcError"===t.name||"InvalidParamsRpcError"===t.name||"MethodNotFoundRpcError"===t.name||"MethodNotSupportedRpcError"===t.name)return await e.request({method:"wallet_sendTransaction",params:[o]},{retryCount:0}).then(t=>(x.set(e.uid,!0),t)).catch(r=>{if("MethodNotFoundRpcError"===r.name||"MethodNotSupportedRpcError"===r.name)throw x.set(e.uid,!1),t;throw r});throw t}}if($?.type==="local"){let t=await (0,v.getAction)(e,y.prepareTransactionRequest,"prepareTransactionRequest")({account:$,accessList:i,authorizationList:s,blobs:c,chain:a,data:l,gas:u,gasPrice:m,maxFeePerBlobGas:b,maxFeePerGas:A,maxPriorityFeePerGas:I,nonce:N,nonceManager:$.nonceManager,parameters:[...y.defaultParameters,"sidecars"],type:R,value:B,...S,to:r}),n=a?.serializers?.transaction,o=await $.signTransaction(t,{serializer:n});return await (0,v.getAction)(e,E.sendRawTransaction,"sendRawTransaction")({serializedTransaction:o})}if($?.type==="smart")throw new p.AccountTypeNotSupportedError({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new p.AccountTypeNotSupportedError({docsPath:"/docs/actions/wallet/sendTransaction",type:$?.type})}catch(e){if(e instanceof p.AccountTypeNotSupportedError)throw e;throw(0,d.getTransactionError)(e,{...t,account:$,chain:t.chain||void 0})}}e.s(["sendTransaction",()=>A],503501);let I="0x5792579257925792579257925792579257925792579257925792579257925792",N=(0,u.numberToHex)(0,{size:32});async function R(e,t){let{account:r=e.account,capabilities:i,chain:p=e.chain,experimental_fallback:h,experimental_fallbackDelay:m=32,forceAtomic:w=!1,id:f,version:g="2.0.0"}=t,v=r?(0,n.parseAccount)(r):null,b=t.calls.map(e=>{let t=e.abi?(0,c.encodeFunctionData)({abi:e.abi,functionName:e.functionName,args:e.args}):e.data;return{data:e.dataSuffix&&t?(0,l.concat)([t,e.dataSuffix]):t,to:e.to,value:e.value?(0,u.numberToHex)(e.value):void 0}});try{let t=await e.request({method:"wallet_sendCalls",params:[{atomicRequired:w,calls:b,capabilities:i,chainId:(0,u.numberToHex)(p.id),from:v?.address,id:f,version:g}]},{retryCount:0});if("string"==typeof t)return{id:t};return t}catch(r){if(h&&("MethodNotFoundRpcError"===r.name||"MethodNotSupportedRpcError"===r.name||"UnknownRpcError"===r.name||r.details.toLowerCase().includes("does not exist / is not available")||r.details.toLowerCase().includes("missing or invalid. request()")||r.details.toLowerCase().includes("did not match any variant of untagged enum")||r.details.toLowerCase().includes("account upgraded to unsupported contract")||r.details.toLowerCase().includes("eip-7702 not supported")||r.details.toLowerCase().includes("unsupported wc_ method")||r.details.toLowerCase().includes("feature toggled misconfigured")||r.details.toLowerCase().includes("jsonrpcengine: response has no error or result for request"))){if(i&&Object.values(i).some(e=>!e.optional)){let e="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new s.UnsupportedNonOptionalCapabilityError(new o.BaseError(e,{details:e}))}if(w&&b.length>1){let e="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new s.AtomicityNotSupportedError(new o.BaseError(e,{details:e}))}let t=[];for(let r of b){let i=A(e,{account:v,chain:p,data:r.data,to:r.to,value:r.value?(0,a.hexToBigInt)(r.value):void 0});t.push(i),m>0&&await new Promise(e=>setTimeout(e,m))}let r=await Promise.allSettled(t);if(r.every(e=>"rejected"===e.status))throw r[0].reason;let n=r.map(e=>"fulfilled"===e.status?e.value:N);return{id:(0,l.concat)([...n,(0,u.numberToHex)(p.id,{size:32}),I])}}throw(0,d.getTransactionError)(r,{...t,account:v,chain:t.chain})}}async function B(e,n){let o;async function s(i){if(i.endsWith(I.slice(2))){let n=(0,r.trim)((0,t.sliceHex)(i,-64,-32)),o=(0,t.sliceHex)(i,0,-64).slice(2).match(/.{1,64}/g),s=await Promise.all(o.map(t=>N.slice(2)!==t?e.request({method:"eth_getTransactionReceipt",params:[`0x${t}`]},{dedupe:!0}):void 0)),c=s.some(e=>null===e)?100:s.every(e=>e?.status==="0x1")?200:s.every(e=>e?.status==="0x0")?500:600;return{atomic:!1,chainId:(0,a.hexToNumber)(n),receipts:s.filter(Boolean),status:c,version:"2.0.0"}}return e.request({method:"wallet_getCallsStatus",params:[i]})}let{atomic:c=!1,chainId:l,receipts:u,version:d="2.0.0",...p}=await s(n.id),[h,m]=(o=p.status)>=100&&o<200?["pending",o]:o>=200&&o<300?["success",o]:o>=300&&o<700?["failure",o]:"CONFIRMED"===o?["success",200]:"PENDING"===o?["pending",100]:[void 0,o];return{...p,atomic:c,chainId:l?(0,a.hexToNumber)(l):void 0,receipts:u?.map(e=>({...e,blockNumber:(0,a.hexToBigInt)(e.blockNumber),gasUsed:(0,a.hexToBigInt)(e.gasUsed),status:i.receiptStatuses[e.status]}))??[],statusCode:m,status:h,version:d}}e.s(["fallbackMagicIdentifier",0,I,"fallbackTransactionErrorMagicIdentifier",0,N,"sendCalls",()=>R],427015),e.s(["getCallsStatus",()=>B],541370)},834819,786387,e=>{"use strict";var t=e.i(534516),r=e.i(12933),a=e.i(225984),i=e.i(914862),n=e.i(828848),o=e.i(47034);async function s(e,s){let{account:c=e.account,chainId:l,nonce:u}=s;if(!c)throw new r.AccountNotFoundError({docsPath:"/docs/eip7702/prepareAuthorization"});let d=(0,t.parseAccount)(c),p=(()=>{if(s.executor)return"self"===s.executor?s.executor:(0,t.parseAccount)(s.executor)})(),h={address:s.contractAddress??s.address,chainId:l,nonce:u};return void 0===h.chainId&&(h.chainId=e.chain?.id??await (0,i.getAction)(e,n.getChainId,"getChainId")({})),void 0===h.nonce&&(h.nonce=await (0,i.getAction)(e,o.getTransactionCount,"getTransactionCount")({address:d.address,blockTag:"pending"}),("self"===p||p?.address&&(0,a.isAddressEqual)(p.address,d.address))&&(h.nonce+=1)),h}e.s(["prepareAuthorization",()=>s],834819);var c=e.i(45710);class l extends c.BaseError{constructor(e){super(`Call bundle failed with status: ${e.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=e}}e.s(["BundleFailedError",()=>l],786387)},93083,e=>{"use strict";var t=e.i(45710),r=e.i(786387),a=e.i(914862),i=e.i(576483),n=e.i(421045),o=e.i(202905),s=e.i(381552),c=e.i(13567),l=e.i(541370);async function u(e,t){let u,{id:p,pollingInterval:h=e.pollingInterval,status:m=({statusCode:e})=>200===e||e>=300,retryCount:w=4,retryDelay:f=({count:e})=>200*~~(1<<e),timeout:g=6e4,throwOnFailure:v=!1}=t,b=(0,c.stringify)(["waitForCallsStatus",e.uid,p]),{promise:T,resolve:C,reject:y}=(0,o.withResolvers)(),E=(0,i.observe)(b,{resolve:C,reject:y},t=>{let i=(0,n.poll)(async()=>{let n=e=>{clearTimeout(u),i(),e(),E()};try{let i=await (0,s.withRetry)(async()=>{let t=await (0,a.getAction)(e,l.getCallsStatus,"getCallsStatus")({id:p});if(v&&"failure"===t.status)throw new r.BundleFailedError(t);return t},{retryCount:w,delay:f});if(!m(i))return;n(()=>t.resolve(i))}catch(e){n(()=>t.reject(e))}},{interval:h,emitOnBegin:!0});return i});return u=g?setTimeout(()=>{E(),clearTimeout(u),y(new d({id:p}))},g):void 0,await T}class d extends t.BaseError{constructor({id:e}){super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}e.s(["waitForCallsStatus",()=>u])}]);